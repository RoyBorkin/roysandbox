<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Snowflake with L-System</title>
    <style>
        body { text-align: center; padding: 20px; font-family: Arial, sans-serif; }
        canvas { border: 1px solid #000; margin-top: 20px; }
        label { margin-right: 10px; }
    </style>
</head>
<body>
    <h1>Generative Snowflake with L-System</h1>
    <div>
        <label for="iterations">Iterations: </label>
        <input type="number" id="iterations" value="4" min="1" max="10">
    </div>
    <div>
        <label for="angle">Angle: </label>
        <input type="number" id="angle" value="15" min="0" max="360">
    </div>
    <div>
        <label for="axiom">Axiom: </label>
        <input type="text" id="axiom" value="F--A">
    </div>
    <div>
        <label for="extrusion">Extrusion Height (mm): </label>
        <input type="number" id="extrusion" value="3" min="1">
    </div>
    <div>
        <label for="circleDiameter">Center Circle Diameter (mm): </label>
        <input type="number" id="circleDiameter" value="20" min="1">
    </div>
    <div>
        <label for="thickness">Face Thickness (mm): </label>
        <input type="number" id="thickness" value="1" min="0.1">
    </div>
	<div>
		<button onclick="generateSnowflake()">Generate Snowflake</button>
		<button onclick="exportOBJ()">Export OBJ</button>
        <button onclick="exportDXF()">Export DXF</button>
        <button onclick="exportSVG()">Export SVG</button>
	</div>
    
    <canvas id="canvas" width="1000" height="1000"></canvas>

    <script>
        let points = [];
        let circlePoints = [];

        function generateSnowflake() {
            const axiom = document.getElementById('axiom').value;
            const iterations = parseInt(document.getElementById('iterations').value);
            const angle = parseInt(document.getElementById('angle').value);
            
            const rules = {
                "F": "F--F++F--F",
                "A": "A--A++A--A"
            };

            let result = axiom;

            for (let i = 0; i < iterations; i++) {
                let next = "";
                for (let char of result) {
                    next += rules[char] || char;
                }
                result = next;
            }

            drawSnowflake(result, angle);
        }

        function drawSnowflake(instructions, angle) {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const length = 10;
            let x = canvas.width / 2, y = canvas.height / 2;
            let dir = 0;

            points = [];
            circlePoints = [];

            points.push([x, y]);

            ctx.beginPath();
            ctx.moveTo(x, y);

            for (let char of instructions) {
                if (char === "F") {
                    x += length * Math.cos(dir * Math.PI / 180);
                    y += length * Math.sin(dir * Math.PI / 180);
                    ctx.lineTo(x, y);
                    points.push([x, y]);
                } else if (char === "A") {
                    x += length * 2 * Math.cos(dir * Math.PI / 180);
                    y += length * 2 * Math.sin(dir * Math.PI / 180);
                    ctx.lineTo(x, y);
                    points.push([x, y]);
                } else if (char === "+") {
                    dir += angle;
                } else if (char === "-") {
                    dir -= angle;
                }
            }

            ctx.stroke();

            const circleDiameter = parseFloat(document.getElementById('circleDiameter').value);
            const radius = circleDiameter / 2;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const segments = 36;

            ctx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * 2 * Math.PI;
                const cx = centerX + radius * Math.cos(theta);
                const cy = centerY + radius * Math.sin(theta);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
                circlePoints.push([cx, cy]);
            }
            ctx.closePath();
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.stroke();
        }

        function exportOBJ() {
            if (points.length === 0 || circlePoints.length === 0) {
                alert("Generate a snowflake first!");
                return;
            }

            const extrusionHeight = parseFloat(document.getElementById('extrusion').value);
            const thickness = parseFloat(document.getElementById('thickness').value);
            let objData = "o Snowflake\n";

            const vertices = [];
            const faces = [];

            function addFace(v1, v2, v3, v4) {
                faces.push([v1, v2, v3, v4]);
            }

            function addVertex(x, y, z) {
                vertices.push([x, y, z]);
                objData += `v ${x.toFixed(4)} ${y.toFixed(4)} ${z.toFixed(4)}\n`;
            }

            points.forEach(([x, y]) => {
                addVertex(x / 50, y / 50, 0);
                addVertex(x / 50, y / 50, extrusionHeight);
            });

            circlePoints.forEach(([x, y]) => {
                addVertex(x / 50, y / 50, 0);
                addVertex(x / 50, y / 50, extrusionHeight);
            });

            for (let i = 0; i < points.length - 1; i++) {
                addFace(i * 2 + 1, i * 2 + 2, i * 2 + 4, i * 2 + 3);
            }

            const offset = points.length * 2;
            for (let i = 0; i < circlePoints.length - 1; i++) {
                addFace(offset + i * 2 + 1, offset + i * 2 + 2, offset + i * 2 + 4, offset + i * 2 + 3);
            }

            faces.forEach(([v1, v2, v3, v4]) => {
                objData += `f ${v1} ${v2} ${v3} ${v4}\n`;
            });

            const blob = new Blob([objData], { type: "text/plain" });
            const link = document.createElement("a");
            link.download = "snowflake_with_thickness.obj";
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportDXF() {
            if (points.length === 0 || circlePoints.length === 0) {
                alert("Generate a snowflake first!");
                return;
            }

            const margin = 10; // Additional margin around the shape
            // Find the bounding box
            const allPoints = [...points, ...circlePoints];
            let minX = Math.min(...allPoints.map(p => p[0])) - margin;
            let minY = Math.min(...allPoints.map(p => p[1])) - margin;
            let maxX = Math.max(...allPoints.map(p => p[0])) + margin;
            let maxY = Math.max(...allPoints.map(p => p[1])) + margin;

            const scale = 100; // Scale to a reasonable size

            let dxfData = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nTABLES\n0\nENDSEC\n0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n";

            function addDXFLine(x1, y1, x2, y2) {
                dxfData += `0\nLINE\n8\n0\n10\n${x1}\n20\n${y1}\n30\n0\n10\n${x2}\n20\n${y2}\n30\n0\n`;
            }

            // Adjust points and draw the snowflake lines
            for (let i = 0; i < points.length - 1; i++) {
                const [x1, y1] = points[i];
                const [x2, y2] = points[i + 1];
                addDXFLine((x1 - minX) * scale, (y1 - minY) * scale, (x2 - minX) * scale, (y2 - minY) * scale);
            }

            // Draw the circle
            for (let i = 0; i < circlePoints.length - 1; i++) {
                const [x1, y1] = circlePoints[i];
                const [x2, y2] = circlePoints[i + 1];
                addDXFLine((x1 - minX) * scale, (y1 - minY) * scale, (x2 - minX) * scale, (y2 - minY) * scale);
            }

            dxfData += "0\nENDSEC\n0\nSECTION\n2\nENDSEC\n0\nEOF";

            const blob = new Blob([dxfData], { type: "text/plain" });
            const link = document.createElement("a");
            link.download = "snowflake.dxf";
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportSVG() {
            if (points.length === 0 || circlePoints.length === 0) {
                alert("Generate a snowflake first!");
                return;
            }

            const margin = 30; // Additional margin around the shape
            // Find the bounding box
            const allPoints = [...points, ...circlePoints];
            let minX = Math.min(...allPoints.map(p => p[0])) - margin;
            let minY = Math.min(...allPoints.map(p => p[1])) - margin;
            let maxX = Math.max(...allPoints.map(p => p[0])) + margin;
            let maxY = Math.max(...allPoints.map(p => p[1])) + margin;

            const scale = 100; // Scale to a reasonable size

            let svgData = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" viewBox="${(minX)} ${(minY)} ${(maxX - minX)} ${(maxY - minY)}" width="500" height="500">\n`;

            // Draw the snowflake lines
            svgData += "<path d='M";
            for (let i = 0; i < points.length; i++) {
                const [x, y] = points[i];
                svgData += ` ${x - minX},${y - minY}`;
            }
            svgData += "' fill='none' stroke='black' stroke-width='1' />\n";

            // Draw the circle
            svgData += "<path d='M";
            for (let i = 0; i < circlePoints.length; i++) {
                const [x, y] = circlePoints[i];
                svgData += ` ${x - minX},${y - minY}`;
            }
            svgData += "' fill='none' stroke='black' stroke-width='1' />\n";
            
            svgData += "</svg>";

            const blob = new Blob([svgData], { type: "image/svg+xml" });
            const link = document.createElement("a");
            link.download = "snowflake.svg";
            link.href = URL.createObjectURL(blob);
            link.click();
        }
    </script>
</body>
</html>
